---
title: mellea.stdlib.genslot
sidebar_label: Genslot
---

# Module: `mellea.stdlib.genslot`

A method to generate outputs based on python functions and a Generative Slot function.

## Functions

### `mellea.stdlib.genslot.create_response_format(func: Callable[..., R])`

Create a Pydantic response format class for a given function.


## Arguments

* `func`: A function with exactly one argument

A Pydantic model class that inherits from FunctionResponse[T]

---

### `mellea.stdlib.genslot.describe_function(func: Callable)`

Generates a FunctionDict given a function.


## Arguments

* `func`: Callable function that needs to be passed to generative slot.


## Returns

* `FunctionDict`: Function dict of the passed function.

---

### `mellea.stdlib.genslot.get_annotation(func: Callable, key: str, val: Any)`

Returns a annotated list of arguments for a given function and list of arguments.


## Arguments

* `func`: Callable Function
* `key`: Arg keys
* `val`: Arg Values


## Returns

* `str`: An annotated string for a given func.

---

### `mellea.stdlib.genslot.bind_function_arguments(func: Callable[P, R], *args: P.args, **kwargs: P.kwargs)`

Bind arguments to function parameters and return as dictionary.


## Arguments

* `func`: The function to bind arguments for. *args: Positional arguments to bind. **kwargs: Keyword arguments to bind.

Dictionary mapping parameter names to bound values with defaults applied.

---

### `mellea.stdlib.genslot.generative(func: Callable[P, R])`

Convert a function into an AI-powered function.

This decorator transforms a regular Python function into one that uses an LLM
to generate outputs. The function's entire signature - including its name,
parameters, docstring, and type hints - is used to instruct the LLM to imitate
that function's behavior. The output is guaranteed to match the return type
annotation using structured outputs and automatic validation.

Tip: Write the function and docstring in the most Pythonic way possible, not
like a prompt. This ensures the function is well-documented, easily understood,
and familiar to any Python developer. The more natural and conventional your
function definition, the better the AI will understand and imitate it.


## Arguments

* `func`: Function with docstring and type hints. Implementation can be empty (...).

An AI-powered function that generates responses using an LLM based on the
original function's signature and docstring.

<CodeGroup>
```python Python
    >>> from mellea import generative, start_session
    >>> session = start_session()
    >>> @generative
    ... def summarize_text(text: str, max_words: int = 50) -> str:
    ...     '''Generate a concise summary of the input text.'''
    ...     ...
    >>>
    >>> summary = summarize_text(session, "Long text...", max_words=30)
```
</CodeGroup>


<CodeGroup>
```python Python
    >>> from typing import List
    >>> from dataclasses import dataclass
    >>>
    >>> @dataclass
    ... class Task:
    ...     title: str
    ...     priority: str
    ...     estimated_hours: float
    >>>
    >>> @generative
    ... def create_project_tasks(project_desc: str, count: int) -> List[Task]:
    ...     '''Generate a list of realistic tasks for a project.
    ...
    ...     Args:
    ...         project_desc: Description of the project
    ...         count: Number of tasks to generate
    ...
    ...     Returns:
    ...         List of tasks with titles, priorities, and time estimates
    ...     '''
    ...     ...
    >>>
    >>> tasks = create_project_tasks(session, "Build a web app", 5)
```
</CodeGroup>


<CodeGroup>
```python Python
    >>> @generative
    ... def analyze_code_quality(code: str) -> Dict[str, Any]:
    ...     '''Analyze code quality and provide recommendations.
    ...
    ...     Args:
    ...         code: Source code to analyze
    ...
    ...     Returns:
    ...         Dictionary containing:
    ...         - score: Overall quality score (0-100)
    ...         - issues: List of identified problems
    ...         - suggestions: List of improvement recommendations
    ...         - complexity: Estimated complexity level
    ...     '''
    ...     ...
    >>>
    >>> analysis = analyze_code_quality(
    ...     session,
    ...     "def factorial(n): return n * factorial(n-1)",
    ...     model_options={"temperature": 0.3}
    ... )
```
</CodeGroup>


<CodeGroup>
```python Python
    >>> @dataclass
    ... class Thought:
    ...     title: str
    ...     body: str
    >>>
    >>> @generative
    ... def generate_chain_of_thought(problem: str, steps: int = 5) -> List[Thought]:
    ...     '''Generate a step-by-step chain of thought for solving a problem.
    ...
    ...     Args:
    ...         problem: The problem to solve or question to answer
    ...         steps: Maximum number of reasoning steps
    ...
    ...     Returns:
    ...         List of reasoning steps, each with a title and detailed body
    ...     '''
    ...     ...
    >>>
    >>> reasoning = generate_chain_of_thought(session, "How to optimize a slow database query?")
```
</CodeGroup>

---

## Classes

### `class mellea.stdlib.genslot.FunctionResponse()`

Generic base class for function response formats.

---

### `class mellea.stdlib.genslot.FunctionDict()`

Return Type for a Function Component.

---

### `class mellea.stdlib.genslot.ArgumentDict()`

Return Type for a Argument Component.

---

### `class mellea.stdlib.genslot.Argument(annotation: str | None = None, name: str | None = None, value: str | None = None)`

An Argument Component.

#### Constructor

An Argument Component.

---

### `class mellea.stdlib.genslot.Function(func: Callable)`

A Function Component.

#### Constructor

A Function Component.

---

### `class mellea.stdlib.genslot.GenerativeSlot(func: Callable[P, R])`

A generative slot component.

#### Constructor

A generative slot function that converts a given `func` to a generative slot.


## Arguments

* `func`: A callable function

#### Methods

##### `mellea.stdlib.genslot.GenerativeSlot.__call__(m, model_options: dict | None = None, *args: P.args, **kwargs: P.kwargs)`

Call the generative slot.


## Arguments

* `m`: `MelleaSession`: A mellea session **kwargs: Additional Kwargs to be passed to the func


## Returns

* `ModelOutputThunk`: Output with generated Thunk.

-----

##### `mellea.stdlib.genslot.GenerativeSlot.parts()`

Not implemented.

-----

##### `mellea.stdlib.genslot.GenerativeSlot.format_for_llm()`

Formats the instruction for Formatter use.

-----

---
