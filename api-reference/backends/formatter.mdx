---
title: Formatter
sidebar_label: Formatter
---

# Module: `formatter`

Abstract interfaces for Formatters.

## Functions

### `_simplify_model_string(input)`

Removes special chars from the given string and lower cases it to simplify matching.

---

### `_get_package_name(module)`

Given a module, attempts to get the package and verifies it exists.

---

## Classes

### `class Formatter`

A Formatter converts `Component`s into strings and parses `ModelOutputThunk`s into `Component`s (or `CBlock`s).

#### Methods

##### `print(self, c)`

Renders a component for input to a model.

-----

##### `print_context(self, ctx)`

Renders a Context for input to a model.

-----

##### `parse(self, source_component, result)`

Parses the output from a model.

-----

##### `to_chat_messages(self, cs)`

Helper method that converts a linearized chat history into a list of messages. The purpose of this helper is to prepare a sequence of Messages for input to a chat endpoint.

-----

---

### `class TemplateFormatter`

Formatter that uses jinja2 templates.

#### Methods

##### `__init__(self, model_id)`

A TemplateFormatter use jinja2 templates.

Args:
model_id: Describes the model for which templates will be looked up. Should match the template dir structure.
template_path: Specify an alternate location where templates can be found. Will be preferred over all other template dirs even if a less exact match is found.
use_template_cache: Cache the location of the most recent templates so that future lookups don't need to be performed. Set to false if you plan on changing the model_id or template_path after the TemplateFormatter has been created.

-----

##### `parse(self, source_component, result)`

Parses the output and updates the result's parsed_repr.

-----

##### `_parse(self, source_component, result)`

Parses the output from a model.

-----

##### `print_context(self, ctx)`

Renders a Context for input to a model.

-----

##### `_stringify(self, c)`

A recursive function that ensures an object is stringified.

For strings and CBlocks, this is just getting their value.
For Components, this means traversing the fields of their template args dictionary and stringifying each part.

Iterables and Mappings should only be encountered as parts of a component's template args. We process each item in them while maintaining the structure.

-----

##### `print(self, c)`

Uses a jinja2 template to pretty-print components.

-----

##### `_load_template(self, repr)`

This method makes an attempt at auto-loading a Template for the Component.

Iterates over template order in the template representation. If it finds
a '*' it will check for a template with the name of the object in 'obj'.
Once it finds a template, it stops searching the list.

To find a template, it looks for it in the following places in order:
1. the user provided template location
2. the component's package or the mellea package if none is found

Raises:
Exception: If there's an unexpected jinja error or the template cannot be found.

-----

##### `_get_template(self, root_path, template_name)`

Attempts to walk the provided directory structure to find the best matching template.

Prefers the most exact match (meaning deepest directory tree) by:
1. Looking for directory names matching the model name
2. Looking in the `prompts/default/` directory for a template

Assumes that only one directory at each level matches.

-----

##### `_get_model_id(self)`

Gets a string representation of the formatter's model id.

-----

---

### `class FormatterBackend`

`FormatterBackend`s support legacy model types.

The `mellea` library was designed to support generative computing with [spanned attention](https://generative.computing/what-are-spans.html) over [generative programming primitives](https://generative.computing/what-are-generative-programs.html).
In the ideal world, context management is handled via span scope-relations and all generative programming primitives are baked into the model via fine-tuning.
I.e., the model's instruction tuning is done in terms of generative programming primitives, and the model is then prompted with the same set of templates that were used for that tuning.

Today, most models do not yet support spans and even those that do are not properly tuned to leverage generative programming primitives.
The `mellea` library supports these legacy models primarily through prompt engineering surfaced via `FormatterBackends`.
A `FormatterBackend` is a backend that uses hand-engineered prompts for rendering generative programming primitives to a model and parsing responses from the model back into `mellea`.
By default, a `FormatterBackend` uses jinja2 templates for pretty-printing, and relies on the user's ad-hoc logic for parsing.

#### Methods

##### `__init__(self, model_id, formatter)`

Initializes a formatter-based backend for `model_id`.

Args:
model_id (str): The model_id to use.
formatter (Formatter): The formatter to use for converting components into (fragments of) prompts.
model_options (Optional[dict]): The model options to use; if None, sensible defaults will be provided.

-----

---
